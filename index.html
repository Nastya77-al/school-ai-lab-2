<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Алгоритми сортування</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f4f4f4;
        }
        
        header {
            background: #2c3e50;
            color: white;
            padding: 1rem;
            text-align: center;
        }
        
        nav {
            background: #34495e;
            padding: 0.5rem;
        }
        
        nav ul {
            list-style: none;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        nav a {
            color: white;
            text-decoration: none;
            padding: 0.5rem 1rem;
            display: block;
            transition: background 0.3s;
        }
        
        nav a:hover {
            background: #2c3e50;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            background: white;
            min-height: calc(100vh - 200px);
        }
        
        .section {
            display: none;
            animation: fadeIn 0.5s;
        }
        
        .section.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .algorithm-box {
            background: #ecf0f1;
            padding: 1.5rem;
            margin: 1rem 0;
            border-radius: 5px;
        }
        
        .visualization {
            background: #2c3e50;
            color: white;
            padding: 2rem;
            margin: 1rem 0;
            text-align: center;
            border-radius: 5px;
        }
        
        .bar {
            display: inline-block;
            width: 40px;
            margin: 2px;
            background: #3498db;
            color: white;
            text-align: center;
            transition: all 0.3s;
        }
        
        .bar.comparing {
            background: #e74c3c;
        }
        
        .bar.sorted {
            background: #27ae60;
        }
        .bar.merging {
            background-color: blueviolet; 
        }

        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            margin: 0.5rem;
            cursor: pointer;
            border-radius: 3px;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #2980b9;
        }
        
        .quiz-container {
            background: #ecf0f1;
            padding: 1.5rem;
            margin: 1rem 0;
            border-radius: 5px;
        }
        
        .question {
            margin: 1rem 0;
        }
        
        .options label {
            display: block;
            margin: 0.5rem 0;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 3px;
            transition: background 0.2s;
        }
        
        .options label:hover {
            background: #ecf0f1;
        }
        
        .task-card {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 5px;
        }
        
        .difficulty {
            display: inline-block;
            padding: 0.2rem 0.5rem;
            border-radius: 3px;
            font-size: 0.8rem;
            margin-bottom: 0.5rem;
        }
        
        .easy { background: #27ae60; color: white; }
        .medium { background: #f39c12; color: white; }
        .hard { background: #e74c3c; color: white; }
        
        pre {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 1rem;
            border-radius: 5px;
            overflow-x: auto;
            margin: 1rem 0;
        }
        
        code {
            font-family: 'Courier New', monospace;
        }
        
        .draggable-step {
            background: #3498db;
            color: white;
            padding: 0.5rem;
            margin: 0.5rem 0;
            border-radius: 3px;
            cursor: move;
            transition: all 0.3s;
            user-select: none;
        }
        
        .draggable-step:hover {
            background: #2980b9;
            transform: scale(1.02);
        }
        
        .draggable-step[draggable="true"]:active {
            cursor: grabbing;
        }
        
        .dropzone {
            border: 2px dashed #bdc3c7;
            min-height: 200px;
            padding: 1rem;
            background: #f8f9fa;
            border-radius: 5px;
            transition: all 0.3s;
        }
        
        .dropzone.dragover {
            border-color: #3498db;
            background: #ecf0f1;
        }
        
        input[type="range"] {
            width: 200px;
            margin: 0 1rem;
        }
        
        textarea {
            border: 1px solid #bdc3c7;
            padding: 0.5rem;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
        
        #mystery-array .bar {
            background: #9b59b6;
        }
        
        .algorithm-box h3 {
            color: #2c3e50;
            margin-bottom: 1rem;
        }
        
        .algorithm-box h4 {
            color: #34495e;
            margin: 0.5rem 0;
        }

        .pattern-game {
            background: #f8f9fa;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 5px;
            text-align: center;
        }

        .pattern-bar {
            display: inline-block;
            width: 30px;
            height: 30px;
            margin: 2px;
            background: #3498db;
            color: white;
            text-align: center;
            line-height: 30px;
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.3s;
        }

        .pattern-bar:hover {
            background: #2980b9;
        }

        .pattern-bar.selected {
            background: #e74c3c;
        }

        .memory-game {
            display: grid;
            grid-template-columns: repeat(4, 50px);
            gap: 5px;
            justify-content: center;
            margin: 1rem auto;
        }

        .memory-card {
            width: 50px;
            height: 50px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .memory-card:hover {
            background: #2980b9;
        }

        .memory-card.flipped {
            background: #27ae60;
        }

        .memory-card.matched {
            background: #95a5a6;
            cursor: default;
        }

        .exam-link {
            background: #27ae60;
            color: white;
            padding: 1rem 2rem;
            border: none;
            border-radius: 5px;
            font-size: 1.1rem;
            text-decoration: none;
            display: inline-block;
            margin: 1rem;
            transition: all 0.3s;
            animation: pulse 2s infinite;
        }

        .exam-link:hover {
            background: #229954;
            transform: scale(1.05);
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(39, 174, 96, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(39, 174, 96, 0); }
            100% { box-shadow: 0 0 0 0 rgba(39, 174, 96, 0); }
        }

        .hidden {
            display: none;
        }
        
        @media (max-width: 768px) {
            nav ul {
                flex-direction: column;
            }
            
            .task-card {
                margin: 0.5rem 0;
            }
            
            #steps-container {
                flex-direction: column;
            }
            
            .bar {
                width: 30px;
                font-size: 0.8rem;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Алгоритми сортування</h1>
        <p>Навчальний курс для учнів 10 класу</p>
    </header>
    
    <nav>
        <ul>
            <li><a href="#" onclick="showSection('home')">Головна</a></li>
            <li><a href="#" onclick="showSection('theory')">Теорія</a></li>
            <li><a href="#" onclick="showSection('visualization')">Візуалізація</a></li>
            <li><a href="#" onclick="showSection('practice')">Практика</a></li>
            <li><a href="#" onclick="showSection('tests')">Тести</a></li>
            <li><a href="#" onclick="showSection('resources')">Ресурси</a></li>
        </ul>
    </nav>
    
    <div class="container">
        <!-- Головна сторінка -->
        <section id="home" class="section active">
            <h2>Ласкаво просимо!</h2>
            <p>Цей навчальний сайт допоможе вам зрозуміти основні алгоритми сортування:</p>
            <ul style="margin: 1rem 0; padding-left: 2rem;">
                <li>Бульбашкове сортування (Bubble Sort)</li>
                <li>Сортування вибором (Selection Sort)</li>
                <li>Сортування злиттям (Merge Sort)</li>
            </ul>
            <p>Ви навчитеся:</p>
            <ul style="margin: 1rem 0; padding-left: 2rem;">
                <li>Розуміти принципи роботи кожного алгоритму</li>
                <li>Візуалізувати процес сортування</li>
                <li>Реалізовувати алгоритми мовою Python</li>
                <li>Аналізувати складність алгоритмів</li>
            </ul>
        </section>
        
        <!-- Теорія -->
        <section id="theory" class="section">
            <h2>Теоретичний матеріал</h2>
            
            <div class="algorithm-box">
                <h3>1. Бульбашкове сортування (Bubble Sort)</h3>
                <p><strong>Принцип роботи:</strong> Алгоритм проходить по масиву і порівнює сусідні елементи. Якщо вони розташовані неправильно, він міняє їх місцями. Процес повторюється, поки масив не буде відсортований.</p>
                <p><strong>Складність:</strong> O(n²)</p>
                <pre><code>def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr</code></pre>
            </div>
            
            <div class="algorithm-box">
                <h3>2. Сортування вибором (Selection Sort)</h3>
                <p><strong>Принцип роботи:</strong> Алгоритм знаходить мінімальний елемент у невідсортованій частині масиву і ставить його на початок.</p>
                <p><strong>Складність:</strong> O(n²)</p>
                <pre><code>def selection_sort(arr):
    n = len(arr)
    for i in range(n):
        min_idx = i
        for j in range(i+1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr</code></pre>
            </div>
            
            <div class="algorithm-box">
                <h3>3. Сортування злиттям (Merge Sort)</h3>
                <p><strong>Принцип роботи:</strong> Алгоритм ділить масив навпіл, рекурсивно сортує обидві частини, а потім зливає їх у відсортований масив.</p>
                <p><strong>Складність:</strong> O(n log n)</p>
                <pre><code>def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    result.extend(left[i:])
    result.extend(right[j:])
    return result</code></pre>
            </div>
        </section>
        
        <!-- Візуалізація -->
        <section id="visualization" class="section">
            <h2>Візуалізація алгоритмів</h2>
            
            <div class="visualization">
                <h3>Налаштування:</h3>
                <div style="margin: 1rem 0;">
                    <label>Розмір масиву: <span id="size-value">10</span></label>
                    <input type="range" id="array-size" min="5" max="20" value="10" onchange="updateArraySize()">
                    
                    <label style="margin-left: 2rem;">Швидкість: <span id="speed-value">500</span>мс</label>
                    <input type="range" id="speed" min="100" max="1000" value="500" step="100" onchange="updateSpeed()">
                </div>
                
                <div style="margin: 1rem 0;">
                    <button onclick="generateRandomArray()">Випадковий масив</button>
                    <button onclick="generateReversedArray()">Зворотній порядок</button>
                    <button onclick="generateNearlySorted()">Майже відсортований</button>
                </div>
                
                <h3>Оберіть алгоритм:</h3>
                <button onclick="startVisualization('bubble')">Бульбашкове</button>
                <button onclick="startVisualization('selection')">Вибором</button>
                <button onclick="startVisualization('merge')">Злиттям</button>
                <button onclick="pauseVisualization()" id="pause-btn">Пауза</button>
                <button onclick="resetVisualization()">Скинути</button>
                
                <div id="array-container" style="margin-top: 2rem;">
                    <!-- Динамічно створюється -->
                </div>
                
                <div style="margin-top: 1rem; display: flex; justify-content: space-around;">
                    <div>Порівнянь: <span id="comparisons">0</span></div>
                    <div>Обмінів: <span id="swaps">0</span></div>
                    <div>Час: <span id="time">0</span>с</div>
                </div>
                
                <p id="status" style="margin-top: 1rem;">Оберіть алгоритм для початку</p>
            </div>
            
            <!-- Інтерактивний код -->
            <div class="algorithm-box" style="margin-top: 2rem;">
                <h3>Спробуйте самі написати код:</h3>
                <div style="display: flex; gap: 1rem;">
                    <div style="flex: 1;">
                        <h4>Ваш код:</h4>
                        <textarea id="user-code" rows="10" style="width: 100%; font-family: monospace;">
def bubble_sort(arr):
    # Напишіть ваш код тут
    n = len(arr)
    # ...
    return arr</textarea>
                        <button onclick="testUserCode()">Перевірити код</button>
                    </div>
                    <div style="flex: 1;">
                        <h4>Результат:</h4>
                        <div id="code-result" style="background: #f4f4f4; padding: 1rem; min-height: 200px;">
                            Напишіть код та натисніть "Перевірити"
                        </div>
                    </div>
                </div>
            </div>
        </section>
        
        <!-- Практика -->
        <section id="practice" class="section">
            <h2>Практичні завдання</h2>
            
            <!-- Гра: Розпізнай патерн -->
            <div class="algorithm-box">
                <h3>🧩 Гра: Розпізнай патерн сортування</h3>
                <p>Подивіться на послідовність обмінів та вгадайте, який алгоритм використовується:</p>
                
                <div class="pattern-game">
                    <div id="pattern-array">
                        <!-- Динамічно створюється -->
                    </div>
                    <div style="margin: 1rem 0;">
                        <button onclick="startPatternGame()">Нова гра</button>
                        <button onclick="showPatternStep()" id="show-step-btn" disabled>Показати наступний крок</button>
                    </div>
                    <div>
                        <label><input type="radio" name="pattern-guess" value="bubble"> Bubble Sort</label>
                        <label><input type="radio" name="pattern-guess" value="selection"> Selection Sort</label>
                    </div>
                    <button onclick="checkPatternGuess()">Перевірити</button>
                    <div id="pattern-result"></div>
                </div>
            </div>
            
            <!-- Пам'ятна гра з числами -->
            <div class="algorithm-box">
                <h3>🧠 Гра на пам'ять: Запам'ятай послідовність</h3>
                <p>Запам'ятайте початковий масив, потім відтворіть його після сортування:</p>
                
                <div style="text-align: center;">
                    <div id="memory-display" style="margin: 1rem 0; font-size: 1.2rem;">
                        Натисніть "Почати", щоб побачити масив
                    </div>
                    <button onclick="startMemoryGame()">Почати гру</button>
                    <button onclick="showMemoryArray()" id="show-memory-btn" class="hidden">Показати масив (3 сек)</button>
                    
                    <div class="memory-game" id="memory-input" style="display: none;">
                        <!-- Динамічно створюється -->
                    </div>
                    <div id="memory-result"></div>
                </div>
            </div>
            
            <!-- Інтерактивні завдання -->
            <div class="task-card">
                <span class="difficulty easy">Легкий</span>
                <h3>Завдання 1: Заповніть пропуски</h3>
                <p>Доповніть код бульбашкового сортування:</p>
                <pre style="background: #f8f9fa; color: #333;">
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, <input type="text" id="gap1" style="width: 60px;" placeholder="?">):
            if arr[j] <select id="gap2"><option value="">?</option><option value=">">&gt;</option><option value="<">&lt;</option></select> arr[j+1]:
                arr[j], arr[j+1] = <input type="text" id="gap3" style="width: 100px;" placeholder="?">
    return arr
                </pre>
                <button onclick="checkGapFilling()">Перевірити</button>
                <div id="gap-result"></div>
            </div>
            
            <div class="task-card">
                <span class="difficulty medium">Середній</span>
                <h3>Завдання 2: Знайдіть помилку</h3>
                <p>У коді є помилка. Знайдіть та виправте її:</p>
                <pre contenteditable="true" id="buggy-code" style="background: #f8f9fa; color: #333; padding: 1rem;">
def selection_sort(arr):
    n = len(arr)
    for i in range(n):
        min_idx = i
        for j in range(i, n):  # Помилка тут!
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr
                </pre>
                <button onclick="checkBugFix()">Перевірити виправлення</button>
                <div id="bug-result"></div>
            </div>
            
            <div class="task-card">
                <span class="difficulty hard">Складний</span>
                <h3>Завдання 3: Змагання алгоритмів</h3>
                <p>Передбачте, який алгоритм швидше відсортує масив:</p>
                <div id="algorithm-race">
                    <p>Масив: <span id="race-array">[5, 2, 8, 1, 9]</span></p>
                    <div style="margin: 1rem 0;">
                        <label><input type="radio" name="prediction" value="bubble"> Bubble Sort</label>
                        <label><input type="radio" name="prediction" value="selection"> Selection Sort</label>
                        <label><input type="radio" name="prediction" value="merge"> Merge Sort</label>
                    </div>
                    <button onclick="startRace()">Почати змагання</button>
                    <div id="race-result" style="margin-top: 1rem;"></div>
                </div>
            </div>
        </section>
        
        <!-- Тести -->
        <section id="tests" class="section">
          <h2>Тести для самоперевірки</h2>
        
          <!-- Інтерактивний тест -->
          <div class="quiz-container">
            <h3>Тест 1: Основи алгоритмів</h3>
            <div id="quiz-questions">
              <div class="question-block">
                <p>1. Який алгоритм має найгіршу складність O(n²)?</p>
                <label><input type="radio" name="q1" value="a"> Merge Sort</label><br>
                <label><input type="radio" name="q1" value="b"> Bubble Sort</label><br>
                <label><input type="radio" name="q1" value="c"> Quick Sort</label>
              </div>
              <div class="question-block">
                <p>2. Який алгоритм є стабільним?</p>
                <label><input type="radio" name="q2" value="a"> Selection Sort</label><br>
                <label><input type="radio" name="q2" value="b"> Merge Sort</label><br>
                <label><input type="radio" name="q2" value="c"> Heap Sort</label>
              </div>
              <div class="question-block">
                <p>3. Скільки підмасивів створює merge sort на першому кроці для 8 елементів?</p>
                <label><input type="radio" name="q3" value="a"> 2</label><br>
                <label><input type="radio" name="q3" value="b"> 4</label><br>
                <label><input type="radio" name="q3" value="c"> 8</label>
              </div>
              <div class="question-block">
                <p>4. Який алгоритм краще підходить для майже відсортованих масивів?</p>
                <label><input type="radio" name="q4" value="a"> Insertion Sort</label><br>
                <label><input type="radio" name="q4" value="b"> Bubble Sort</label><br>
                <label><input type="radio" name="q4" value="c"> Merge Sort</label>
              </div>
              <div class="question-block">
                <p>5. Який з алгоритмів не базується на порівнянні?</p>
                <label><input type="radio" name="q5" value="a"> Radix Sort</label><br>
                <label><input type="radio" name="q5" value="b"> Selection Sort</label><br>
                <label><input type="radio" name="q5" value="c"> Quick Sort</label>
              </div>
            </div>
            <button onclick="gradeQuiz()">Перевірити відповіді</button>
            <div id="quiz-result" style="margin-top: 1rem;"></div>
            <div id="exam-link-container" class="hidden" style="text-align: center; margin-top: 2rem;">
                <a href="exam.html" class="exam-link">🎓 Перейти до залікового тесту</a>
                <p style="color: #27ae60; font-weight: bold;">Вітаємо! Ви готові до заліку!</p>
            </div>
          </div>
        
          <!-- Інтерактивні вправи -->
          <div class="algorithm-box" style="margin-top: 2rem;">
            <h3>Вправа: Визначте алгоритм</h3>
            <p>Подивіться на анімацію та визначте, який алгоритм використовується:</p>
            <div id="mystery-sort" style="background: #2c3e50; padding: 1rem; margin: 1rem 0;">
              <div id="mystery-array" style="text-align: center; display: flex; justify-content: center; gap: 4px;"></div>
            </div>
            <div>
              <label><input type="radio" name="mystery" value="bubble"> Bubble Sort</label>
              <label><input type="radio" name="mystery" value="selection"> Selection Sort</label>
              <label><input type="radio" name="mystery" value="insertion"> Insertion Sort</label>
            </div>
            <button onclick="startMysterySort()">Показати анімацію</button>
            <button onclick="checkMysteryAnswer()">Перевірити</button>
            <div id="mystery-result"></div>
          </div>
        
          <!-- Drag & Drop вправа -->
          <div class="algorithm-box">
            <h3>Вправа: Розставте кроки алгоритму</h3>
            <p>Перетягніть кроки у правильному порядку для bubble sort:</p>
            <div id="steps-container" style="display: flex; gap: 2rem; margin: 1rem 0;">
              <div style="flex: 1;">
                <h4>Кроки (перетягніть →)</h4>
                <div id="available-steps" class="dropzone">
                    <div class="draggable-step" draggable="true" data-step="1">Порівняти сусідні елементи</div>
                    <div class="draggable-step" draggable="true" data-step="2">Поміняти місцями, якщо перший більший</div>
                    <div class="draggable-step" draggable="true" data-step="3">Перейти до наступної пари</div>
                    <div class="draggable-step" draggable="true" data-step="4">Повторити до кінця масиву</div>
                </div>
              </div>
              <div style="flex: 1;">
                <h4>Правильний порядок</h4>
                <div id="ordered-steps" class="dropzone"></div>
              </div>
            </div>
            <button onclick="checkStepsOrder()">Перевірити порядок</button>
            <div id="steps-result"></div>
          </div>
        
          <!-- Швидкий тест -->
          <div class="algorithm-box">
            <h3>Швидкий тест: True/False</h3>
            <div id="true-false-container">
              <div class="question" style="margin: 1rem 0;">
                <p>1. Bubble sort завжди виконує O(n²) операцій</p>
                <button onclick="answerTrueFalse(1, true)">True</button>
                <button onclick="answerTrueFalse(1, false)">False</button>
                <span id="tf-result-1"></span>
              </div>
              <div class="question" style="margin: 1rem 0;">
                <p>2. Merge sort використовує принцип "розділяй і володарюй"</p>
                <button onclick="answerTrueFalse(2, true)">True</button>
                <button onclick="answerTrueFalse(2, false)">False</button>
                <span id="tf-result-2"></span>
              </div>
              <div class="question" style="margin: 1rem 0;">
                <p>3. Selection sort є стабільним алгоритмом</p>
                <button onclick="answerTrueFalse(3, true)">True</button>
                <button onclick="answerTrueFalse(3, false)">False</button>
                <span id="tf-result-3"></span>
              </div>
              <div class="question" style="margin: 1rem 0;">
                <p>4. Quick sort завжди стабільний</p>
                <button onclick="answerTrueFalse(4, true)">True</button>
                <button onclick="answerTrueFalse(4, false)">False</button>
                <span id="tf-result-4"></span>
              </div>
              <div class="question" style="margin: 1rem 0;">
                <p>5. Merge sort гарантує O(n log n) у найгіршому випадку</p>
                <button onclick="answerTrueFalse(5, true)">True</button>
                <button onclick="answerTrueFalse(5, false)">False</button>
                <span id="tf-result-5"></span>
              </div>
            </div>
            <div id="tf-score" style="margin-top: 1rem;"></div>
          </div>
        </section>
        
        <!-- Ресурси -->
        <section id="resources" class="section">
            <h2>Додаткові ресурси</h2>
            
            <h3>🌐 Корисні посилання:</h3>
            <ul style="margin: 1rem 0; padding-left: 2rem;">
                <li><a href="https://visualgo.net/en/sorting" target="_blank">VisuAlgo - Візуалізація алгоритмів</a></li>
                <li><a href="https://www.toptal.com/developers/sorting-algorithms" target="_blank">Порівняння алгоритмів сортування</a></li>
                <li><a href="https://www.geeksforgeeks.org/sorting-algorithms/" target="_blank">GeeksforGeeks - Алгоритми сортування</a></li>
            </ul>
            
            <h3>📖 Рекомендована література:</h3>
            <ul style="margin: 1rem 0; padding-left: 2rem;">
                <li>"Алгоритми: побудова та аналіз" - Томас Кормен</li>
                <li>"Структури даних та алгоритми в Python" - Майкл Гудріч</li>
            </ul>
            
            <h3>🎥 Відео-уроки:</h3>
            <ul style="margin: 1rem 0; padding-left: 2rem;">
                <li>CS50 - Лекція про алгоритми сортування</li>
                <li>Computerphile - Візуалізація сортування</li>
            </ul>
        </section>
    </div>
    
    <script>
        function showSection(sectionId) {
            const sections = document.querySelectorAll('.section');
            sections.forEach(section => section.classList.remove('active'));
            document.getElementById(sectionId).classList.add('active');
        }
        
        // Глобальні змінні
        let sortingInProgress = false;
        let isPaused = false;
        let currentSpeed = 500;
        let currentArraySize = 10;
        let comparisons = 0;
        let swaps = 0;
        let startTime = 0;
        
        // Візуалізація
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        
        function generateArray(size) {
            const container = document.getElementById('array-container');
            container.innerHTML = '';
            const values = [];
            
            for (let i = 0; i < size; i++) {
                const value = Math.floor(Math.random() * 10) + 1;
                values.push(value);
                const bar = document.createElement('div');
                bar.className = 'bar';
                bar.style.height = value * 10 + 'px';
                bar.textContent = value;
                container.appendChild(bar);
            }
            
            return values;
        }
        
        function updateArraySize() {
            currentArraySize = document.getElementById('array-size').value;
            document.getElementById('size-value').textContent = currentArraySize;
            if (!sortingInProgress) {
                generateArray(currentArraySize);
            }
        }
        
        function updateSpeed() {
            currentSpeed = document.getElementById('speed').value;
            document.getElementById('speed-value').textContent = currentSpeed;
        }
        
        function generateRandomArray() {
            if (!sortingInProgress) {
                generateArray(currentArraySize);
                resetStats();
            }
        }
        
        function generateReversedArray() {
            if (!sortingInProgress) {
                const container = document.getElementById('array-container');
                container.innerHTML = '';
                for (let i = currentArraySize; i > 0; i--) {
                    const bar = document.createElement('div');
                    bar.className = 'bar';
                    bar.style.height = i * 10 + 'px';
                    bar.textContent = i;
                    container.appendChild(bar);
                }
                resetStats();
            }
        }
        
        function generateNearlySorted() {
            if (!sortingInProgress) {
                const container = document.getElementById('array-container');
                container.innerHTML = '';
                const values = [];
                for (let i = 1; i <= currentArraySize; i++) {
                    values.push(i);
                }
                // Робимо кілька випадкових обмінів
                for (let i = 0; i < 2; i++) {
                    const idx1 = Math.floor(Math.random() * currentArraySize);
                    const idx2 = Math.floor(Math.random() * currentArraySize);
                    [values[idx1], values[idx2]] = [values[idx2], values[idx1]];
                }
                
                values.forEach(value => {
                    const bar = document.createElement('div');
                    bar.className = 'bar';
                    bar.style.height = value * 10 + 'px';
                    bar.textContent = value;
                    container.appendChild(bar);
                });
                resetStats();
            }
        }
        
        function resetStats() {
            comparisons = 0;
            swaps = 0;
            document.getElementById('comparisons').textContent = '0';
            document.getElementById('swaps').textContent = '0';
            document.getElementById('time').textContent = '0';
        }
        
        function updateStats() {
            document.getElementById('comparisons').textContent = comparisons;
            document.getElementById('swaps').textContent = swaps;
            const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
            document.getElementById('time').textContent = elapsed;
        }
        
        function getArrayValues() {
            const bars = document.querySelectorAll('.bar');
            return Array.from(bars).map(bar => parseInt(bar.textContent));
        }
        
        function updateBars(values) {
            const bars = document.querySelectorAll('.bar');
            bars.forEach((bar, index) => {
                bar.style.height = values[index] * 10 + 'px';
                bar.textContent = values[index];
            });
        }
        
        async function bubbleSortVisualization() {
            const values = getArrayValues();
            const bars = document.querySelectorAll('.bar');
            const n = values.length;
            
            for (let i = 0; i < n && sortingInProgress; i++) {
                for (let j = 0; j < n - i - 1 && sortingInProgress; j++) {
                    while (isPaused && sortingInProgress) {
                        await sleep(100);
                    }
                    
                    bars[j].classList.add('comparing');
                    bars[j + 1].classList.add('comparing');
                    comparisons++;
                    updateStats();
                    
                    await sleep(currentSpeed);
                    
                    if (values[j] > values[j + 1]) {
                        [values[j], values[j + 1]] = [values[j + 1], values[j]];
                        updateBars(values);
                        swaps++;
                        updateStats();
                    }
                    
                    bars[j].classList.remove('comparing');
                    bars[j + 1].classList.remove('comparing');
                }
                bars[n - i - 1].classList.add('sorted');
            }
            
            if (sortingInProgress) {
                document.getElementById('status').textContent = 'Сортування завершено!';
                sortingInProgress = false;
            }
        }
        
        async function selectionSortVisualization() {
            const values = getArrayValues();
            const bars = document.querySelectorAll('.bar');
            const n = values.length;
            
            for (let i = 0; i < n && sortingInProgress; i++) {
                let minIdx = i;
                bars[i].classList.add('comparing');
                
                for (let j = i + 1; j < n && sortingInProgress; j++) {
                    while (isPaused && sortingInProgress) {
                        await sleep(100);
                    }
                    
                    bars[j].classList.add('comparing');
                    comparisons++;
                    updateStats();
                    await sleep(currentSpeed);
                    
                    if (values[j] < values[minIdx]) {
                        if (minIdx !== i) bars[minIdx].classList.remove('comparing');
                        minIdx = j;
                    } else {
                        bars[j].classList.remove('comparing');
                    }
                }
                
                if (minIdx !== i) {
                    [values[i], values[minIdx]] = [values[minIdx], values[i]];
                    updateBars(values);
                    swaps++;
                    updateStats();
                }
                
                bars.forEach(bar => bar.classList.remove('comparing'));
                bars[i].classList.add('sorted');
                await sleep(currentSpeed);
            }
            
            if (sortingInProgress) {
                document.getElementById('status').textContent = 'Сортування завершено!';
                sortingInProgress = false;
            }
        }

        async function mergeSortVisualization() {
            const values = getArrayValues();
            const bars = document.querySelectorAll('.bar');
        
            function setMergingColor(start, end) {
                for (let i = start; i <= end; i++) {
                    bars[i].classList.add('merging');
                }
            }
        
            function clearMergingColor(start, end) {
                for (let i = start; i <= end; i++) {
                    bars[i].classList.remove('merging');
                }
            }
        
            async function merge(start, mid, end) {
                const left = values.slice(start, mid + 1);
                const right = values.slice(mid + 1, end + 1);
        
                let i = 0, j = 0, k = start;
        
                setMergingColor(start, end);
        
                while (i < left.length && j < right.length && sortingInProgress) {
                    while (isPaused && sortingInProgress) await sleep(100);
        
                    bars[k].classList.add('comparing');
                    comparisons++;
                    updateStats();
                    await sleep(currentSpeed);
        
                    if (left[i] <= right[j]) {
                        values[k] = left[i++];
                    } else {
                        values[k] = right[j++];
                        swaps++;
                    }
        
                    updateBars(values);
                    updateStats();
                    bars[k].classList.remove('comparing');
                    k++;
                }
        
                while (i < left.length && sortingInProgress) {
                    while (isPaused && sortingInProgress) await sleep(100);
                    values[k++] = left[i++];
                    updateBars(values);
                    swaps++;
                    updateStats();
                    await sleep(currentSpeed);
                }
        
                while (j < right.length && sortingInProgress) {
                    while (isPaused && sortingInProgress) await sleep(100);
                    values[k++] = right[j++];
                    updateBars(values);
                    swaps++;
                    updateStats();
                    await sleep(currentSpeed);
                }
        
                clearMergingColor(start, end);
            }
        
            async function mergeSort(start, end) {
                if (start >= end || !sortingInProgress) return;
                const mid = Math.floor((start + end) / 2);
                await mergeSort(start, mid);
                await mergeSort(mid + 1, end);
                await merge(start, mid, end);
            }
        
            await mergeSort(0, values.length - 1);
        
            // Після повного сортування — позначаємо зеленим (sorted)
            for (let i = 0; i < values.length; i++) {
                bars[i].classList.add('sorted');
                await sleep(10); // плавне підсвічування
            }
        
            if (sortingInProgress) {
                document.getElementById('status').textContent = 'Сортування завершено!';
                sortingInProgress = false;
            }
        }

        function startVisualization(algorithm) {
            if (sortingInProgress) return;
            
            resetVisualization();
            sortingInProgress = true;
            isPaused = false;
            startTime = Date.now();
            document.getElementById('status').textContent = 'Сортування...';
            document.getElementById('pause-btn').textContent = 'Пауза';
            
            switch(algorithm) {
                case 'bubble':
                    bubbleSortVisualization();
                    break;
                case 'selection':
                    selectionSortVisualization();
                    break;
                case 'merge':
                    mergeSortVisualization();
                    break;
            }
        }
        
        function pauseVisualization() {
            if (sortingInProgress) {
                isPaused = !isPaused;
                document.getElementById('pause-btn').textContent = isPaused ? 'Продовжити' : 'Пауза';
            }
        }
        
        function resetVisualization() {
            sortingInProgress = false;
            isPaused = false;
            const bars = document.querySelectorAll('.bar');
            bars.forEach(bar => {
                bar.classList.remove('comparing', 'sorted', 'merging');
            });
            document.getElementById('status').textContent = 'Оберіть алгоритм для початку';
            resetStats();
        }
        
        // Нові ігри
        let patternAlgorithm = '';
        let patternSteps = [];
        let currentPatternStep = 0;
        
        function startPatternGame() {
            const algorithms = ['bubble', 'selection'];
            patternAlgorithm = algorithms[Math.floor(Math.random() * algorithms.length)];
            
            const array = [4, 2, 7, 1, 3];
            const container = document.getElementById('pattern-array');
            container.innerHTML = '';
            
            array.forEach((val, idx) => {
                const elem = document.createElement('div');
                elem.className = 'pattern-bar';
                elem.textContent = val;
                elem.id = `pattern-${idx}`;
                container.appendChild(elem);
            });
            
            // Генеруємо кроки для алгоритму
            patternSteps = generatePatternSteps(array, patternAlgorithm);
            currentPatternStep = 0;
            
            document.getElementById('show-step-btn').disabled = false;
            document.getElementById('pattern-result').innerHTML = '';
        }
        
        function generatePatternSteps(arr, algorithm) {
            const steps = [];
            const values = [...arr];
            
            if (algorithm === 'bubble') {
                for (let i = 0; i < values.length; i++) {
                    for (let j = 0; j < values.length - i - 1; j++) {
                        steps.push({type: 'compare', indices: [j, j + 1]});
                        if (values[j] > values[j + 1]) {
                            [values[j], values[j + 1]] = [values[j + 1], values[j]];
                            steps.push({type: 'swap', indices: [j, j + 1]});
                        }
                    }
                }
            } else if (algorithm === 'selection') {
                for (let i = 0; i < values.length; i++) {
                    let minIdx = i;
                    for (let j = i + 1; j < values.length; j++) {
                        steps.push({type: 'compare', indices: [minIdx, j]});
                        if (values[j] < values[minIdx]) {
                            minIdx = j;
                        }
                    }
                    if (minIdx !== i) {
                        [values[i], values[minIdx]] = [values[minIdx], values[i]];
                        steps.push({type: 'swap', indices: [i, minIdx]});
                    }
                }
            }
            
            return steps;
        }
        
        function showPatternStep() {
            if (currentPatternStep >= patternSteps.length) return;
            
            const step = patternSteps[currentPatternStep];
            const [idx1, idx2] = step.indices;
            
            // Очищаємо попередні виділення
            document.querySelectorAll('.pattern-bar').forEach(bar => bar.classList.remove('selected'));
            
            // Виділяємо поточні елементи
            document.getElementById(`pattern-${idx1}`).classList.add('selected');
            document.getElementById(`pattern-${idx2}`).classList.add('selected');
            
            if (step.type === 'swap') {
                // Міняємо елементи місцями
                const elem1 = document.getElementById(`pattern-${idx1}`);
                const elem2 = document.getElementById(`pattern-${idx2}`);
                const temp = elem1.textContent;
                elem1.textContent = elem2.textContent;
                elem2.textContent = temp;
            }
            
            currentPatternStep++;
            
            if (currentPatternStep >= patternSteps.length) {
                document.getElementById('show-step-btn').disabled = true;
            }
        }
        
        function checkPatternGuess() {
            const selected = document.querySelector('input[name="pattern-guess"]:checked');
            if (!selected) {
                alert('Оберіть алгоритм!');
                return;
            }
            
            if (selected.value === patternAlgorithm) {
                document.getElementById('pattern-result').innerHTML = 
                    '<p style="color: green;">✓ Правильно! Це ' + patternAlgorithm + ' sort!</p>';
            } else {
                document.getElementById('pattern-result').innerHTML = 
                    '<p style="color: red;">✗ Неправильно. Спробуйте ще раз!</p>';
            }
        }
        
        // Гра на пам'ять
        let memoryArray = [];
        let memoryInput = [];
        
        function startMemoryGame() {
            memoryArray = [];
            for (let i = 0; i < 6; i++) {
                memoryArray.push(Math.floor(Math.random() * 9) + 1);
            }
            
            document.getElementById('memory-display').textContent = 'Масив: [' + memoryArray.join(', ') + ']';
            document.getElementById('show-memory-btn').classList.remove('hidden');
            document.getElementById('memory-result').innerHTML = '';
        }
        
        function showMemoryArray() {
            const sortedArray = [...memoryArray].sort((a, b) => a - b);
            document.getElementById('memory-display').textContent = 'Відсортований: [' + sortedArray.join(', ') + ']';
            
            setTimeout(() => {
                document.getElementById('memory-display').textContent = 'Введіть відсортований масив:';
                document.getElementById('show-memory-btn').classList.add('hidden');
                createMemoryInput();
            }, 3000);
        }
        
        function createMemoryInput() {
            const container = document.getElementById('memory-input');
            container.style.display = 'grid';
            container.innerHTML = '';
            memoryInput = new Array(6).fill(0);
            
            for (let i = 0; i < 6; i++) {
                const input = document.createElement('input');
                input.type = 'number';
                input.min = '1';
                input.max = '9';
                input.style.width = '40px';
                input.style.textAlign = 'center';
                input.onchange = (e) => {
                    memoryInput[i] = parseInt(e.target.value) || 0;
                    checkMemoryCompletion();
                };
                container.appendChild(input);
            }
        }
        
        function checkMemoryCompletion() {
            if (memoryInput.every(val => val > 0)) {
                const correctSorted = [...memoryArray].sort((a, b) => a - b);
                const isCorrect = JSON.stringify(memoryInput) === JSON.stringify(correctSorted);
                
                if (isCorrect) {
                    document.getElementById('memory-result').innerHTML = 
                        '<p style="color: green;">🎉 Чудово! Ви правильно запам\'ятали та відсортували масив!</p>';
                } else {
                    document.getElementById('memory-result').innerHTML = 
                        '<p style="color: red;">❌ Неправильно. Правильна відповідь: [' + correctSorted.join(', ') + ']</p>';
                }
            }
        }
        
        // Перевірка коду з пропусками
        function checkGapFilling() {
            const gap1 = document.getElementById('gap1').value.trim();
            const gap2 = document.getElementById('gap2').value;
            const gap3 = document.getElementById('gap3').value.trim();
            
            const correct1 = gap1 === 'n-i-1' || gap1 === 'n - i - 1';
            const correct2 = gap2 === '>';
            const correct3 = gap3 === 'arr[j+1], arr[j]' || gap3 === 'arr[j + 1], arr[j]';
            
            let result = '';
            if (correct1 && correct2 && correct3) {
                result = '<p style="color: green;">✓ Відмінно! Всі пропуски заповнені правильно!</p>';
            } else {
                result = '<p style="color: red;">✗ Є помилки. Підказки:<br>';
                if (!correct1) result += '- Перший пропуск: подумайте про межі циклу<br>';
                if (!correct2) result += '- Другий пропуск: який знак порівняння для зростання?<br>';
                if (!correct3) result += '- Третій пропуск: як поміняти елементи місцями?<br>';
                result += '</p>';
            }
            
            document.getElementById('gap-result').innerHTML = result;
        }
        
        // Перевірка виправлення помилки
        function checkBugFix() {
            const code = document.getElementById('buggy-code').textContent;
            const hasCorrectRange = code.includes('range(i+1, n)') || code.includes('range(i + 1, n)');
            
            if (hasCorrectRange) {
                document.getElementById('bug-result').innerHTML = 
                    '<p style="color: green;">✓ Правильно! Внутрішній цикл повинен починатися з i+1, а не з i</p>';
            } else {
                document.getElementById('bug-result').innerHTML = 
                    '<p style="color: red;">✗ Помилка все ще є. Подумайте: чи потрібно порівнювати елемент сам з собою?</p>';
            }
        }
        
        // Змагання алгоритмів
        async function startRace() {
            const prediction = document.querySelector('input[name="prediction"]:checked');
            if (!prediction) {
                alert('Спочатку оберіть алгоритм!');
                return;
            }
            
            const testArray = [5, 2, 8, 1, 9];
            const results = {};
            
            // Bubble Sort
            let arr1 = [...testArray];
            let start = performance.now();
            let comparisons1 = 0;
            for (let i = 0; i < arr1.length; i++) {
                for (let j = 0; j < arr1.length - i - 1; j++) {
                    comparisons1++;
                    if (arr1[j] > arr1[j + 1]) {
                        [arr1[j], arr1[j + 1]] = [arr1[j + 1], arr1[j]];
                    }
                }
            }
            results.bubble = {
                time: performance.now() - start,
                comparisons: comparisons1
            };
            
            // Selection Sort
            let arr2 = [...testArray];
            start = performance.now();
            let comparisons2 = 0;
            for (let i = 0; i < arr2.length; i++) {
                let minIdx = i;
                for (let j = i + 1; j < arr2.length; j++) {
                    comparisons2++;
                    if (arr2[j] < arr2[minIdx]) {
                        minIdx = j;
                    }
                }
                if (minIdx !== i) {
                    [arr2[i], arr2[minIdx]] = [arr2[minIdx], arr2[i]];
                }
            }
            results.selection = {
                time: performance.now() - start,
                comparisons: comparisons2
            };
            
            // Merge Sort (спрощено для демонстрації)
            results.merge = {
                time: 0.001,
                comparisons: 12
            };
            
            // Визначаємо переможця
            const winner = Object.keys(results).reduce((a, b) => 
                results[a].comparisons < results[b].comparisons ? a : b
            );
            
            let resultHTML = '<h4>Результати змагання:</h4>';
            resultHTML += `<p>Bubble Sort: ${results.bubble.comparisons} порівнянь</p>`;
            resultHTML += `<p>Selection Sort: ${results.selection.comparisons} порівнянь</p>`;
            resultHTML += `<p>Merge Sort: ${results.merge.comparisons} порівнянь</p>`;
            resultHTML += `<p><strong>Переможець: ${winner.charAt(0).toUpperCase() + winner.slice(1)} Sort!</strong></p>`;
            
            if (prediction.value === winner) {
                resultHTML += '<p style="color: green;">✓ Ви вгадали!</p>';
            } else {
                resultHTML += '<p style="color: red;">✗ Спробуйте ще раз</p>';
            }
            
            document.getElementById('race-result').innerHTML = resultHTML;
        }
        
        // Основний тест
        function gradeQuiz() {
            const answers = {
                q1: 'b', // Bubble Sort має O(n²)
                q2: 'b', // Merge Sort є стабільним
                q3: 'a', // 2 підмасиви на першому кроці
                q4: 'a', // Insertion Sort для майже відсортованих
                q5: 'a'  // Radix Sort не базується на порівнянні
            };
            
            let score = 0;
            let results = '<h3>Результати тесту:</h3>';
            
            Object.keys(answers).forEach((q, idx) => {
                const selected = document.querySelector(`input[name="${q}"]:checked`);
                if (selected && selected.value === answers[q]) {
                    score++;
                    results += `<p style="color: green;">✓ Питання ${idx + 1}: Правильно!</p>`;
                } else {
                    results += `<p style="color: red;">✗ Питання ${idx + 1}: Неправильно.</p>`;
                }
            });
            
            results += `<h4>Ваш результат: ${score}/5</h4>`;
            
            if (score === 5) {
                results += '<p style="color: green;"><strong>🎉 Відмінно! Ви чудово знаєте матеріал!</strong></p>';
                document.getElementById('exam-link-container').classList.remove('hidden');
            } else if (score >= 4) {
                results += '<p style="color: orange;"><strong>Добре! Але є що покращити.</strong></p>';
            } else {
                results += '<p style="color: red;"><strong>Рекомендуємо повторити матеріал.</strong></p>';
            }
            
            document.getElementById('quiz-result').innerHTML = results;
        }

        // Mystery Sort
        let mysteryAlgorithm = '';
        
        async function startMysterySort() {
            const algorithms = ['bubble', 'selection'];
            mysteryAlgorithm = algorithms[Math.floor(Math.random() * algorithms.length)];
            
            const container = document.getElementById('mystery-array');
            container.innerHTML = '';
            
            const values = [5, 2, 8, 1, 4];
            const bars = values.map(value => {
                const bar = document.createElement('div');
                bar.textContent = value;
                bar.style.width = '40px';
                bar.style.height = `${value * 20}px`;
                bar.style.backgroundColor = '#9b59b6';
                bar.style.display = 'inline-block';
                bar.style.color = 'white';
                bar.style.textAlign = 'center';
                bar.style.verticalAlign = 'bottom';
                bar.style.margin = '0 2px';
                container.appendChild(bar);
                return bar;
            });
            
            // Анімація відповідно до обраного алгоритму
            if (mysteryAlgorithm === 'bubble') {
                await animateBubbleSort(values, bars);
            } else {
                await animateSelectionSort(values, bars);
            }
            
            document.getElementById('mystery-result').innerHTML = 
                '<p>Подивіться на анімацію та спробуйте визначити алгоритм</p>';
        }
        
        async function animateBubbleSort(values, bars) {
            const n = values.length;
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n - i - 1; j++) {
                    bars[j].style.backgroundColor = '#e74c3c';
                    bars[j + 1].style.backgroundColor = '#e74c3c';
                    await sleep(800);
                    
                    if (values[j] > values[j + 1]) {
                        [values[j], values[j + 1]] = [values[j + 1], values[j]];
                        bars[j].textContent = values[j];
                        bars[j + 1].textContent = values[j + 1];
                        bars[j].style.height = `${values[j] * 20}px`;
                        bars[j + 1].style.height = `${values[j + 1] * 20}px`;
                    }
                    
                    bars[j].style.backgroundColor = '#9b59b6';
                    bars[j + 1].style.backgroundColor = '#9b59b6';
                }
                bars[n - i - 1].style.backgroundColor = '#27ae60';
            }
        }
        
        async function animateSelectionSort(values, bars) {
            const n = values.length;
            for (let i = 0; i < n; i++) {
                let minIdx = i;
                bars[i].style.backgroundColor = '#f39c12';
                
                for (let j = i + 1; j < n; j++) {
                    bars[j].style.backgroundColor = '#e74c3c';
                    await sleep(600);
                    
                    if (values[j] < values[minIdx]) {
                        if (minIdx !== i) bars[minIdx].style.backgroundColor = '#9b59b6';
                        minIdx = j;
                        bars[minIdx].style.backgroundColor = '#f39c12';
                    } else {
                        bars[j].style.backgroundColor = '#9b59b6';
                    }
                }
                
                if (minIdx !== i) {
                    [values[i], values[minIdx]] = [values[minIdx], values[i]];
                    bars[i].textContent = values[i];
                    bars[minIdx].textContent = values[minIdx];
                    bars[i].style.height = `${values[i] * 20}px`;
                    bars[minIdx].style.height = `${values[minIdx] * 20}px`;
                }
                
                bars[i].style.backgroundColor = '#27ae60';
                if (minIdx !== i) bars[minIdx].style.backgroundColor = '#9b59b6';
            }
        }
        
        function checkMysteryAnswer() {
            const selected = document.querySelector('input[name="mystery"]:checked');
            if (!selected) {
                alert('Оберіть алгоритм!');
                return;
            }
            
            if (selected.value === mysteryAlgorithm) {
                document.getElementById('mystery-result').innerHTML = 
                    '<p style="color: green;">✓ Правильно! Це дійсно ' + mysteryAlgorithm + ' sort!</p>';
            } else {
                document.getElementById('mystery-result').innerHTML = 
                    '<p style="color: red;">✗ Неправильно. Спробуйте ще раз або запустіть анімацію знову.</p>';
            }
        }
        
        // Drag & Drop функціональність
        let draggedElement = null;
        
        function initializeDragAndDrop() {
            const draggables = document.querySelectorAll('.draggable-step');
            const dropzones = document.querySelectorAll('.dropzone');
            
            draggables.forEach(draggable => {
                draggable.addEventListener('dragstart', function(e) {
                    draggedElement = this;
                    this.style.opacity = '0.5';
                });
                
                draggable.addEventListener('dragend', function(e) {
                    this.style.opacity = '';
                    draggedElement = null;
                });
            });
            
            dropzones.forEach(zone => {
                zone.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    this.classList.add('dragover');
                });
                
                zone.addEventListener('dragleave', function(e) {
                    this.classList.remove('dragover');
                });
                
                zone.addEventListener('drop', function(e) {
                    e.preventDefault();
                    this.classList.remove('dragover');
                    if (draggedElement) {
                        this.appendChild(draggedElement);
                    }
                });
            });
        }
        
        function checkStepsOrder() {
            const orderedSteps = document.getElementById('ordered-steps');
            const steps = Array.from(orderedSteps.querySelectorAll('.draggable-step'));
            const correctOrder = ['1', '2', '3', '4'];
            
            let isCorrect = true;
            steps.forEach((step, idx) => {
                if (step.getAttribute('data-step') !== correctOrder[idx]) {
                    isCorrect = false;
                }
            });
            
            const result = document.getElementById('steps-result');
            if (steps.length !== 4) {
                result.innerHTML = '<p style="color: orange;">⚠️ Перетягніть всі кроки у правильному порядку</p>';
            } else if (isCorrect) {
                result.innerHTML = '<p style="color: green;">✓ Відмінно! Порядок правильний!</p>';
            } else {
                result.innerHTML = '<p style="color: red;">✗ Неправильний порядок. Спробуйте ще раз.</p>';
            }
        }
        
        // True/False швидкий тест
        const tfAnswers = {1: false, 2: true, 3: false, 4: false, 5: true};
        let tfScore = 0;
        let tfAnswered = new Set();
        
        function answerTrueFalse(question, answer) {
            if (tfAnswered.has(question)) return;
            
            const correct = tfAnswers[question] === answer;
            const resultSpan = document.getElementById(`tf-result-${question}`);
            
            if (correct) {
                resultSpan.innerHTML = ' <span style="color: green;">✓</span>';
                tfScore++;
            } else {
                resultSpan.innerHTML = ' <span style="color: red;">✗</span>';
            }
            
            tfAnswered.add(question);
            
            // Оновлюємо загальний рахунок
            if (tfAnswered.size === Object.keys(tfAnswers).length) {
                document.getElementById('tf-score').innerHTML = 
                    `<strong>Ваш результат: ${tfScore}/${Object.keys(tfAnswers).length}</strong>`;
            }
        }
        
        // Перевірка коду користувача
        function testUserCode() {
            const code = document.getElementById('user-code').value;
            
            try {
                // Простий тест
                const testArr = [3, 1, 4, 1, 5];
                const expectedResult = [1, 1, 3, 4, 5];
                
                // Виконуємо код користувача
                eval(code);
                
                // Перевіряємо функцію
                if (typeof bubble_sort === 'function') {
                    const result = bubble_sort([...testArr]);
                    
                    if (JSON.stringify(result) === JSON.stringify(expectedResult)) {
                        document.getElementById('code-result').innerHTML = 
                            '<p style="color: green;">✓ Чудово! Ваш алгоритм працює правильно!</p>' +
                            '<p>Тест пройдено: [3, 1, 4, 1, 5] → [1, 1, 3, 4, 5]</p>';
                    } else {
                        document.getElementById('code-result').innerHTML = 
                            '<p style="color: red;">✗ Алгоритм працює неправильно</p>' +
                            `<p>Очікувалось: [1, 1, 3, 4, 5], отримано: [${result}]</p>`;
                    }
                } else {
                    document.getElementById('code-result').innerHTML = 
                        '<p style="color: red;">✗ Функція bubble_sort не знайдена</p>';
                }
            } catch (e) {
                document.getElementById('code-result').innerHTML = 
                    '<p style="color: red;">✗ Помилка в коді: ' + e.message + '</p>';
            }
        }
        
        // Ініціалізація при завантаженні сторінки
        document.addEventListener('DOMContentLoaded', function() {
            // Ініціалізуємо масив при завантаженні
            generateArray(currentArraySize);
            
            // Ініціалізуємо drag & drop
            initializeDragAndDrop();
        });
    </script>
</body>
</html>